<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random Chat Debug</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f0f0f0;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .video-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        video {
            width: 100%;
            height: 300px;
            background: #000;
            border-radius: 10px;
        }
        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        .primary { background: #007bff; color: white; }
        .danger { background: #dc3545; color: white; }
        .secondary { background: #6c757d; color: white; }
        .status {
            background: #e9ecef;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: monospace;
        }
        .log {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 10px;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
        }
        .error { color: #dc3545; }
        .success { color: #28a745; }
        .warning { color: #ffc107; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Random Chat Feature Debug</h1>
        
        <div class="status">
            <div><strong>Connection Status:</strong> <span id="connectionStatus">Disconnected</span></div>
            <div><strong>Camera Permission:</strong> <span id="cameraPermission">Pending</span></div>
            <div><strong>Partner Status:</strong> <span id="partnerStatus">No partner</span></div>
            <div><strong>WebRTC State:</strong> <span id="webrtcState">Not initialized</span></div>
        </div>

        <div class="controls">
            <button id="startBtn" class="primary">Start Chat</button>
            <button id="endBtn" class="danger">End Chat</button>
            <button id="nextBtn" class="secondary">Next Partner</button>
            <button id="testCameraBtn" class="secondary">Test Camera</button>
            <button id="clearLogBtn" class="secondary">Clear Log</button>
        </div>

        <div class="video-container">
            <div>
                <h3>Local Video (You)</h3>
                <video id="localVideo" autoplay muted playsinline></video>
            </div>
            <div>
                <h3>Remote Video (Partner)</h3>
                <video id="remoteVideo" autoplay playsinline></video>
            </div>
        </div>

        <div>
            <h3>Debug Log</h3>
            <div id="debugLog" class="log"></div>
        </div>
    </div>

    <script>
        // Debug logging
        const debugLog = document.getElementById('debugLog');
        const log = (message, type = 'info') => {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${message}\n`;
            debugLog.innerHTML += `<span class="${type}">${logEntry}</span>`;
            debugLog.scrollTop = debugLog.scrollHeight;
            console.log(message);
        };

        // Status updaters
        const updateStatus = (elementId, value, className = '') => {
            const element = document.getElementById(elementId);
            element.textContent = value;
            element.className = className;
        };

        // Mock WebRTC and Signaling for testing
        class MockWebRTCService {
            constructor() {
                this.localStream = null;
                this.remoteStream = null;
                this.peerConnection = null;
                this.dataChannel = null;
            }

            async initializeMedia() {
                try {
                    log('Requesting camera and microphone access...', 'info');
                    updateStatus('cameraPermission', 'Requesting...', 'warning');
                    
                    this.localStream = await navigator.mediaDevices.getUserMedia({
                        video: { width: 640, height: 480 },
                        audio: true
                    });
                    
                    const localVideo = document.getElementById('localVideo');
                    localVideo.srcObject = this.localStream;
                    
                    updateStatus('cameraPermission', 'Granted', 'success');
                    log('✓ Camera and microphone access granted', 'success');
                    return this.localStream;
                } catch (error) {
                    updateStatus('cameraPermission', 'Denied', 'error');
                    log(`✗ Media access failed: ${error.message}`, 'error');
                    throw error;
                }
            }

            createPeerConnection() {
                try {
                    log('Creating peer connection...', 'info');
                    this.peerConnection = new RTCPeerConnection({
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' }
                        ]
                    });

                    this.peerConnection.onconnectionstatechange = () => {
                        const state = this.peerConnection.connectionState;
                        updateStatus('webrtcState', state);
                        log(`WebRTC connection state: ${state}`, 
                            state === 'connected' ? 'success' : 
                            state === 'failed' ? 'error' : 'info');
                    };

                    this.peerConnection.onicecandidate = (event) => {
                        if (event.candidate) {
                            log('ICE candidate generated', 'info');
                        }
                    };

                    this.peerConnection.ontrack = (event) => {
                        log('Remote track received', 'success');
                        const remoteVideo = document.getElementById('remoteVideo');
                        remoteVideo.srcObject = event.streams[0];
                        updateStatus('partnerStatus', 'Connected', 'success');
                    };

                    // Add local stream tracks
                    if (this.localStream) {
                        this.localStream.getTracks().forEach(track => {
                            this.peerConnection.addTrack(track, this.localStream);
                        });
                    }

                    log('✓ Peer connection created successfully', 'success');
                } catch (error) {
                    log(`✗ Failed to create peer connection: ${error.message}`, 'error');
                    throw error;
                }
            }

            cleanup() {
                if (this.peerConnection) {
                    this.peerConnection.close();
                    this.peerConnection = null;
                }
                if (this.localStream) {
                    this.localStream.getTracks().forEach(track => track.stop());
                    this.localStream = null;
                }
                updateStatus('webrtcState', 'Cleaned up');
                updateStatus('partnerStatus', 'Disconnected');
                log('✓ WebRTC cleanup completed', 'info');
            }
        }

        class MockSignalingService {
            constructor() {
                this.connected = false;
                this.partner = null;
            }

            async connect() {
                log('Connecting to signaling service...', 'info');
                // Simulate connection delay
                await new Promise(resolve => setTimeout(resolve, 1000));
                this.connected = true;
                updateStatus('connectionStatus', 'Connected to signaling', 'success');
                log('✓ Connected to mock signaling service', 'success');
            }

            joinRoom(roomId) {
                if (!this.connected) {
                    log('✗ Cannot join room: not connected to signaling', 'error');
                    return;
                }
                
                log(`Joining room: ${roomId}`, 'info');
                updateStatus('connectionStatus', 'Searching for partner...', 'warning');
                
                // Simulate finding a partner after 2-5 seconds
                const delay = 2000 + Math.random() * 3000;
                setTimeout(() => {
                    this.partner = 'mock-partner-' + Math.random().toString(36).substr(2, 9);
                    updateStatus('connectionStatus', 'Partner found!', 'success');
                    updateStatus('partnerStatus', 'Found partner', 'success');
                    log(`✓ Partner found: ${this.partner}`, 'success');
                    
                    // Trigger WebRTC connection
                    if (webRTCService.peerConnection) {
                        this.simulateWebRTCHandshake();
                    }
                }, delay);
            }

            simulateWebRTCHandshake() {
                log('Simulating WebRTC handshake...', 'info');
                // Simulate successful connection after a short delay
                setTimeout(() => {
                    updateStatus('webrtcState', 'connected');
                    log('✓ WebRTC connection established', 'success');
                }, 1000);
            }

            disconnect() {
                this.connected = false;
                this.partner = null;
                updateStatus('connectionStatus', 'Disconnected');
                updateStatus('partnerStatus', 'No partner');
                log('Disconnected from signaling service', 'info');
            }
        }

        // Initialize services
        const webRTCService = new MockWebRTCService();
        const signalingService = new MockSignalingService();

        // Button event handlers
        document.getElementById('startBtn').addEventListener('click', async () => {
            try {
                log('=== Starting chat session ===', 'info');
                updateStatus('connectionStatus', 'Initializing...', 'warning');
                
                // Step 1: Initialize media
                await webRTCService.initializeMedia();
                
                // Step 2: Create peer connection
                webRTCService.createPeerConnection();
                
                // Step 3: Connect to signaling
                await signalingService.connect();
                
                // Step 4: Join room to find partner
                const roomId = 'test-room-' + Date.now();
                signalingService.joinRoom(roomId);
                
            } catch (error) {
                log(`✗ Failed to start chat: ${error.message}`, 'error');
                updateStatus('connectionStatus', 'Failed', 'error');
            }
        });

        document.getElementById('endBtn').addEventListener('click', () => {
            log('=== Ending chat session ===', 'info');
            webRTCService.cleanup();
            signalingService.disconnect();
            updateStatus('connectionStatus', 'Disconnected');
            updateStatus('partnerStatus', 'No partner');
            updateStatus('webrtcState', 'Disconnected');
        });

        document.getElementById('nextBtn').addEventListener('click', () => {
            log('=== Finding next partner ===', 'info');
            signalingService.disconnect();
            const roomId = 'test-room-' + Date.now();
            signalingService.connect().then(() => {
                signalingService.joinRoom(roomId);
            });
        });

        document.getElementById('testCameraBtn').addEventListener('click', async () => {
            try {
                log('=== Testing camera only ===', 'info');
                await webRTCService.initializeMedia();
            } catch (error) {
                log(`✗ Camera test failed: ${error.message}`, 'error');
            }
        });

        document.getElementById('clearLogBtn').addEventListener('click', () => {
            debugLog.innerHTML = '';
            log('Debug log cleared', 'info');
        });

        // Initial log
        log('Random Chat Debug Tool initialized', 'success');
        log('Click "Test Camera" to check camera permissions', 'info');
        log('Click "Start Chat" to test the full flow', 'info');
    </script>
</body>
</html>